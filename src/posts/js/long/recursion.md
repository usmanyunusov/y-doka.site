---
title: Рекурсия
name: recursion
author: bespoyasov
co-authors:
designers:
contributors:
summary:
  - function
  - call
---

## Кратко

_Рекурсия_ — это что-то, что описывает само себя.

Представить рекурсию проще всего на примере зеркального коридора — когда напротив друг друга стоят два зеркала. Если посмотреть в одно, то в нём будет отражение второго, во втором — отражение первого и так далее.

<figure>
<img src="/assets/images/posts/recursion/mirror-corridor.jpg" alt="Кадр из Inception, directed by Christopher Nolan. 2010; UK: Warner Bros. Pictures" />
<figcaption>
В «Начале» Нолана есть момент с зеркальным коридором, когда в отражении зеркала видно отражение зеркала, в котором видно отражение зеркала, в котором видно...
</figcaption>
</figure>

Второй пример, чуть более академически правильный — это фрактал. Тот же [треугольник Серпинского](https://ru.wikipedia.org/wiki/Треугольник_Серпинского) — это пример рекурсии, потому что часть фигуры — это одновременно вся фигура.

<figure>
<img src="/assets/images/posts/recursion/serpinsky-triangle.jpg" />
<figcaption>
Треугольник состоит из 3 точно таких же треугольников
</figcaption>
</figure>

В программировании под рекурсией чаще всего понимают функцию, которая вызывает саму себя.

## Рекурсия в программировании

При решении некоторых задач мы можем обнаружить, что решение можно разбить на несколько простых действий и более простой вариант той же задачи.

Например, при возведении числа в степень мы берём число, умножаем его на себя несколько раз. Эту операцию можно представить в виде:

```js
// 2^5 = 2 * 2 * 2 * 2 * 2
//
// 1 шаг: 2
// 2 шаг: 2 * 2
// 3 шаг: 2 * 2 * 2
// 4 шаг: 2 * 2 * 2 * 2
// 5 шаг: 2 * 2 * 2 * 2 * 2
//
// Какой по счёту шаг —
// столько и умножений.
```

Но это же можно представить в виде нескольких последовательных умножений на 2:

```js
// 2^5 = ((((2 * 2) * 2) * 2) * 2)
//
// 1 шаг: 2
// 2 шаг: 2 * 2  (результат 1-го шага * 2)
// 3 шаг: 4 * 2  (результат 2-го шага * 2)
// 4 шаг: 8 * 2  (результат 3-го шага * 2)
// 5 шаг: 16 * 2  (результат 4-го шага * 2)
//
// Для получения нового результата
// мы берём предыдущий и умножаем его на 2.
```

При таком представлении всё возведение в степень — это лишь умножение предыдущего результата на 2:

```js
// 2^n = 2^(n-1) * 2
// Значение степени двойки —
// это предыдущее значение, умноженное на 2.
```

Именно такие задачи называются _рекурсивными_ — когда часть условия ссылается на всю задачу в целом (или похожую на неё).

### Повторяющиеся операции

Одна из двух составляющих рекурсии — это повторяющиеся операции. В примере с возведением в степень — это умножение.

Повторяющиеся операции могут быть довольно сложными и включать в себя несколько подзадач. Такое, например, часто встречается в математике.

<aside class="callout">

Знаменитая [сумма всех натуральных чисел](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_⋯) контринтуитивно равняется -1/12. А [доказывается](https://www.youtube.com/watch?v=w-I6XTVZXww) это именно рекурсивно.

</aside>

### Базовый случай

Вторая важная часть рекурсии — это базовый случай.

<aside class="callout">

_Базовый случай_ — это условие, при выполнении которого рекурсия заканчивается и функция больше не вызывает саму себя.

</aside>

Например, при возведении в степень базовый случай наступает, когда значение степени становится равно искомому.

<figure>
<img src="/assets/images/posts/recursion/base-case.jpg" />
<figcaption>
Как только выполнение доходит до базового случая, оно останавливается
</figcaption>
</figure>

Без базового случая любая рекурсивная функция уйдёт в бесконечное выполнение, потому что будет вызывать себя без конца.

В JS это приводит в переполнению [стека вызовов](/posts/js/long/async-in-js/#стек-вызовов), и функция останавливается с ошибкой.

<figure>
<img src="/assets/images/posts/recursion/call-stack-exceeded.jpg" />
<figcaption>
Если выполнить функцию без базового случая, которая лишь вызывает себя, получим ошибку
</figcaption>
</figure>

## Цикл и рекурсия

### Возведение в степень с помощью цикла

### Возведение в степень с помощью рекурсии

## Структуры данных и обходы

### Деревья

### Связанные списки (?)

### Рекурсивный обход
