---
title: Рекурсия
name: recursion
author: bespoyasov
co-authors:
designers:
contributors:
summary:
  - function
  - call
---

## Кратко

_Рекурсия_ — это что-то, что описывает само себя.

Представить рекурсию проще всего на примере зеркального коридора — когда напротив друг друга стоят два зеркала. Если посмотреть в одно, то в нём будет отражение второго, во втором — отражение первого и так далее.

<figure>
<img src="/assets/images/posts/recursion/mirror-corridor.jpg" alt="Кадр из Inception, directed by Christopher Nolan. 2010; UK: Warner Bros. Pictures" />
<figcaption>
В «Начале» Нолана есть момент с зеркальным коридором, когда в отражении зеркала видно отражение зеркала, в котором видно отражение зеркала, в котором видно...
</figcaption>
</figure>

Второй пример, чуть более академически правильный — это фрактал. Тот же [треугольник Серпинского](https://ru.wikipedia.org/wiki/Треугольник_Серпинского) — это пример рекурсии, потому что часть фигуры — это одновременно вся фигура.

<figure>
<img src="/assets/images/posts/recursion/serpinsky-triangle.jpg" />
<figcaption>
Треугольник состоит из 3 точно таких же треугольников
</figcaption>
</figure>

В программировании под рекурсией чаще всего понимают функцию, которая вызывает саму себя.

## Рекурсия в программировании

При решении некоторых задач мы можем обнаружить, что решение можно разбить на несколько простых действий и более простой вариант той же задачи.

Например, при возведении числа в степень мы берём число, умножаем его на себя несколько раз. Эту операцию можно представить в виде:

```js
// 2^5 = 2 * 2 * 2 * 2 * 2
//
// 1 шаг: 2
// 2 шаг: 2 * 2
// 3 шаг: 2 * 2 * 2
// 4 шаг: 2 * 2 * 2 * 2
// 5 шаг: 2 * 2 * 2 * 2 * 2
//
// Какой по счёту шаг —
// столько и умножений.
```

Но это же можно представить в виде нескольких последовательных умножений на 2:

```js
// 2^5 = ((((2 * 2) * 2) * 2) * 2)
//
// 1 шаг: 2
// 2 шаг: 2 * 2  (результат 1-го шага * 2)
// 3 шаг: 4 * 2  (результат 2-го шага * 2)
// 4 шаг: 8 * 2  (результат 3-го шага * 2)
// 5 шаг: 16 * 2  (результат 4-го шага * 2)
//
// Для получения нового результата
// мы берём предыдущий и умножаем его на 2.
```

При таком представлении всё возведение в степень — это лишь умножение предыдущего результата на 2:

```js
// 2^n = 2^(n-1) * 2
// Значение степени двойки —
// это предыдущее значение, умноженное на 2.
```

Именно такие задачи называются _рекурсивными_ — когда часть условия ссылается на всю задачу в целом (или похожую на неё).

### Повторяющиеся операции

Одна из двух составляющих рекурсии — это повторяющиеся операции. В примере с возведением в степень — это умножение.

Повторяющиеся операции могут быть довольно сложными и включать в себя несколько подзадач. Такое, например, часто встречается в математике.

<aside class="callout">

Знаменитая [сумма всех натуральных чисел](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_⋯) контринтуитивно равняется -1/12. А [доказывается](https://www.youtube.com/watch?v=w-I6XTVZXww) это именно рекурсивно.

</aside>

### Базовый случай

Вторая важная часть рекурсии — это базовый случай.

<aside class="callout">

_Базовый случай_ — это условие, при выполнении которого рекурсия заканчивается и функция больше не вызывает саму себя.

</aside>

Например, при возведении в степень базовый случай наступает, когда значение степени становится равно искомому.

<figure>
<img src="/assets/images/posts/recursion/base-case.jpg" />
<figcaption>
Как только выполнение доходит до базового случая, оно останавливается
</figcaption>
</figure>

Без базового случая любая рекурсивная функция уйдёт в бесконечное выполнение, потому что будет вызывать себя без конца.

В JS это приводит в переполнению [стека вызовов](/posts/js/long/async-in-js/#стек-вызовов), и функция останавливается с ошибкой.

<figure>
<img src="/assets/images/posts/recursion/call-stack-exceeded.jpg" />
<figcaption>
Если выполнить функцию без базового случая, которая лишь вызывает себя, получим ошибку
</figcaption>
</figure>

## Цикл и рекурсия

Из-за повторяющихся операций рекурсия схожа с циклом. Их часто считают взаимозаменяемыми, но это всё же не совсем так.

Рекурсия проигрывает циклу в следующем:

- Она может приводить к переполнению стека. Особенно это ощутимо в таких языках как JS, где переполнение стека может наступить раньше базового случая с высокой вероятностью.
- Её выполнение может (хотя не обязательно) занимать больше памяти.
- Отлаживать рекурсию значительно сложнее, чем цикл. (А если функция написана плохо — то и просто читать.)

Цикл же проигрывает рекурсии в таких вещах:

- Его нельзя использовать в [функциональном программировании](/posts/js/long/programming-paradigms/), потому что он императивен.
- Циклом гораздо сложнее обходить вложенные структуры данных, как например каталоги файлов.
- Результат выполнения рекурсивной функции проще закешировать, чтобы ускорить выполнение, с циклом это сделать сложнее.
- При работе с общими ресурсами или асинхронными задачами чаще удобнее использовать рекурсивные функции из-за замыканий.

Поэтому на вопрос «Что использовать: рекурсию или цикл?» ответом будет «Зависит от задачи», серебряной пули здесь нет :–)

Давайте теперь попробуем решить одну и ту же задачу с использованием цикла и рекурсии, чтобы увидеть разницу в подходах. Будем писать функцию для нахождения факториала.

<aside class="callout">

_Факториал числа_ — это произведение всех чисел от единицы до этого числа.

</aside>

### Факториал с помощью цикла

Сперва решим задачу нахождения факториала с помощью цикла.

```js
function factorial(n) {
  // Начальный результат будет равен 1,
  // чтобы его можно было умножать на последующие числа.
  // 0 подходит только для подсчёта суммы,
  // потому что умножение на 0 всегда даёт 0.
  let result = 1

  for (let i = 0; i < n; i++) {
    // Так как наш счётчик начинается с 0
    // и растёт до n-1, нам нужно прибавить к нему
    // единицу, чтобы правильно рассчитать произведение.
    result *= i + 1
  }

  return result
}

factorial(5) // 120
```

В этой функции мы используем цикл, чтобы умножить каждое число на результат предыдущего умножения. То же самое мы можем сделать и рекурсивно.

### Факториал с помощью рекурсии

Для расчёта факториала рекурсивно мы создадим функцию, в которой в первую очередь опишем базовый случай, а уже потом — повторяющиеся действия.

<aside class="callout">

Хорошим правилом при работе с рекурсией считается первым делом описывать базовый случай (как ранний выход, early return) и только потом — всё остальное. Это позволяет сделать работу с рекурсией безопаснее.

</aside>

<figure>
<img src="/assets/images/posts/recursion/block-scheme.jpg" />
<figcaption>
В виде блок-схемы мы можем представить алгоритм факториала как условие и под-вызов той же функции
</figcaption>
</figure>

```js
function factorial(n) {
  // Если мы пытаемся найти факториал 1,
  // возвращаем 1 — это базовый случай.
  if (n <= 1) {
    return 1
  }

  // В остальных случаях
  // возвращаем произведение n
  // на факториал предыдущего числа —
  // таким образом мы от n дойдём до 1,
  // перебрав каждое число.
  return n * factorial(n - 1)
}

factorial(5) // 120
```

Кроме того, что функция стала заметно короче, она теперь выражает непосредственно математическую суть факториала.

<aside class="callout">

Отчасти поэтому в академических статьях большим уважением пользуется рекурсивный подход, хотя это и не очень объективно ¯\\\_(ツ)\_/¯

</aside>

<figure>
<img src="/assets/images/posts/recursion/factorial.jpg" />
<figcaption>
Процесс вычисления факториала 5 будет состоять из 4 под-вызовов функции `factorial()`
</figcaption>
</figure>

## Структуры данных и обходы

### Деревья

### Связанные списки (?)

### Рекурсивный обход
